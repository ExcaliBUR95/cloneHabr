"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imgDiff = exports.registerDecoder = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const pixelmatch_1 = __importDefault(require("pixelmatch"));
const pngjs_1 = require("pngjs");
const mkdirp_1 = __importDefault(require("mkdirp"));
const decode_png_1 = __importDefault(require("./decode-png"));
const decode_jpeg_1 = __importDefault(require("./decode-jpeg"));
const decode_tiff_1 = __importDefault(require("./decode-tiff"));
const expand_1 = __importDefault(require("./expand"));
const extensionDecoderMap = {};
function registerDecoder(extensions, decoder) {
    extensions.forEach(extension => {
        if (!extension.startsWith(".")) {
            extension = `.${extension}`;
        }
        extensionDecoderMap[extension] = decoder;
    });
}
exports.registerDecoder = registerDecoder;
function decode(filename) {
    const ext = path_1.default.extname(filename);
    const decoder = extensionDecoderMap[ext];
    if (!ext || !decoder) {
        const exts = Object.keys(extensionDecoderMap).join(", ");
        throw new Error("File name should be end with " + exts);
    }
    return decoder(filename);
}
registerDecoder(["png"], decode_png_1.default);
registerDecoder(["jpg", "jpeg"], decode_jpeg_1.default);
registerDecoder(["tiff"], decode_tiff_1.default);
function compare(img1, img2, diffFilename, generateOnlyDiffFile = false, options = { threshold: 0.1, includeAA: false }) {
    const { dataList, width, height } = expand_1.default(img1, img2);
    const diff = new pngjs_1.PNG({ width, height });
    const pmOpt = Object.assign({ threshold: 0 }, options);
    const count = pixelmatch_1.default(dataList[0], dataList[1], diff.data, width, height, pmOpt);
    const imagesAreSame = count === 0;
    const result = {
        width,
        height,
        imagesAreSame,
        diffCount: count,
    };
    if (!diffFilename) {
        return Promise.resolve(result);
    }
    if (imagesAreSame && generateOnlyDiffFile) {
        return Promise.resolve(result);
    }
    mkdirp_1.default.sync(path_1.default.dirname(diffFilename));
    const out = fs_1.default.createWriteStream(diffFilename);
    const p = new Promise((resolve, reject) => {
        out.on("finish", () => resolve(result)).on("error", err => reject(err));
    });
    diff.pack().pipe(out);
    return p;
}
function imgDiff(opt) {
    return Promise.all([decode(opt.actualFilename), decode(opt.expectedFilename)]).then(imgs => {
        return compare(imgs[0], imgs[1], opt.diffFilename, opt.generateOnlyDiffFile, opt.options);
    });
}
exports.imgDiff = imgDiff;
//# sourceMappingURL=index.js.map